# Apple Foundation Models Framework API Documentation

## Overview

The Foundation Models framework provides access to Apple's on-device large language model that powers Apple Intelligence for iOS 26.0+ Beta.

**Official Documentation:** https://developer.apple.com/documentation/foundationmodels

## Availability Requirements

- **iOS/iPadOS:** 26.0+ Beta
- **macOS:** 26.0+ Beta  
- **visionOS:** 26.0+ Beta
- **Mac Catalyst:** 26.0+ Beta

### Device Requirements
- Device must support Apple Intelligence
- Apple Intelligence must be enabled in System Settings
- Device must have sufficient battery
- Device cannot be in Game Mode

## Core Classes

### SystemLanguageModel
**Documentation:** https://developer.apple.com/documentation/foundationmodels/systemlanguagemodel

The main class for accessing Apple's on-device language model.

```swift
import FoundationModels

// Get the default model
let model = SystemLanguageModel.default

// Create model for specific use case
let model = SystemLanguageModel(useCase: .contentTagging)

// Check availability
switch model.availability {
case .available:
    // Model is ready to use
case .unavailable(.deviceNotEligible):
    // Device doesn't support Apple Intelligence
case .unavailable(.appleIntelligenceNotEnabled):
    // Apple Intelligence disabled in Settings
case .unavailable(.modelNotReady):
    // Model downloading or system busy
case .unavailable(let other):
    // Other availability issue
}
```

#### Key Properties
- `isAvailable: Bool` - Convenience check for readiness
- `availability: SystemLanguageModel.Availability` - Detailed availability status
- `supportedLanguages: Set<Locale.Language>` - Supported languages

#### Use Cases
```swift
struct UseCase {
    static let contentTagging: UseCase
    // Other use cases available
}
```

### LanguageModelSession
**Documentation:** https://developer.apple.com/documentation/foundationmodels/languagemodelsession

Manages interactions with the language model, maintains context between requests.

```swift
// Create session with instructions
let session = LanguageModelSession(
    model: SystemLanguageModel.default,
    instructions: """
    You are a helpful assistant that provides concise, 
    accurate responses.
    """
)

// Generate text response
let response = try await session.respond(to: "Explain quantum computing")

// Generate structured response
struct Summary: Generable {
    let title: String
    let keyPoints: [String]
}

let summary = try await session.respond(
    to: "Summarize this article",
    generating: Summary.self
)
```

#### Session Features
- **Context Preservation:** Maintains conversation state
- **Transcript Access:** Full history via `session.transcript`
- **Streaming:** Real-time response generation
- **Tool Calling:** Custom function execution
- **Guided Generation:** Structured output with `@Generable`

## Guided Generation (@Generable)

**Documentation:** https://developer.apple.com/documentation/foundationmodels/generating-swift-data-structures-with-guided-generation

Generate structured Swift data types directly from the model.

```swift
@Generable
struct ProductInfo {
    let name: String
    let price: Double
    let category: String
    let features: [String]
}

let product = try await session.respond(
    to: "Extract product info from this description",
    generating: ProductInfo.self
)
```

### Key Protocol
```swift
protocol Generable {
    // Types conforming to this can be generated by the model
}
```

## Tool Calling

**Documentation:** https://developer.apple.com/documentation/foundationmodels/expanding-generation-with-tool-calling

Extend model capabilities with custom tools.

```swift
struct WeatherTool: Tool {
    func definition() -> ToolDefinition {
        ToolDefinition(
            name: "get_weather",
            description: "Get current weather for a location",
            parameters: [
                "location": .string(description: "City name")
            ]
        )
    }
    
    func invoke(arguments: [String: Any]) async throws -> String {
        let location = arguments["location"] as? String ?? ""
        // Implement weather lookup
        return "Current weather in \(location): 72Â°F, sunny"
    }
}

// Use tool in session
let session = LanguageModelSession(
    model: SystemLanguageModel.default,
    tools: [WeatherTool()]
)
```

## Response Types

### Basic Text Response
```swift
let response: LanguageModelSession.Response<String> = try await session.respond(to: prompt)
print(response.content) // Generated text
```

### Structured Response
```swift
let response: LanguageModelSession.Response<MyType> = try await session.respond(
    to: prompt,
    generating: MyType.self
)
print(response.content) // Instance of MyType
```

### Streaming Response
```swift
let stream = session.streamResponse(to: prompt)
for try await chunk in stream {
    print(chunk.content) // Partial response
}
```

## Error Handling

```swift
enum LanguageModelSession.GenerationError {
    case exceededContextWindowSize(Int)
    case modelUnavailable
    case invalidPrompt
    // Other errors
}

do {
    let response = try await session.respond(to: prompt)
} catch LanguageModelSession.GenerationError.exceededContextWindowSize(let size) {
    // Handle context overflow
} catch {
    // Handle other errors
}
```

## Safety and Guardrails

**Documentation:** https://developer.apple.com/documentation/foundationmodels/improving-safety-from-generative-model-output

```swift
struct Guardrails {
    // Configure safety filtering
}

let session = LanguageModelSession(
    model: SystemLanguageModel.default,
    guardrails: .default
)
```

## Best Practices

### 1. Check Availability First
```swift
guard model.isAvailable else {
    // Show appropriate UI for unavailable state
    return
}
```

### 2. Handle All Availability Cases
```swift
switch model.availability {
case .available:
    // Proceed with AI features
case .unavailable(.appleIntelligenceNotEnabled):
    // Guide user to enable Apple Intelligence
case .unavailable(.deviceNotEligible):
    // Show alternative non-AI features
case .unavailable(.modelNotReady):
    // Show loading state or retry later
case .unavailable(let other):
    // Log for debugging, show generic error
}
```

### 3. Use Appropriate Instructions
```swift
let session = LanguageModelSession(
    instructions: """
    You are an expert in [domain]. Provide [specific guidance on tone, 
    format, and constraints]. Always [specific requirements].
    """
)
```

### 4. Implement Proper Error Handling
```swift
do {
    let response = try await session.respond(to: prompt)
    // Handle success
} catch LanguageModelSession.GenerationError.exceededContextWindowSize(_) {
    // Start new session or truncate context
} catch {
    // Handle other errors gracefully
}
```

### 5. Optimize Performance
```swift
// Preload model resources
session.prewarm()

// Reuse sessions when possible
// Create new session only when context needs reset
```

## Example Implementation

```swift
import FoundationModels

@available(iOS 26.0, *)
class FoundationModelsProvider: ObservableObject {
    @Published var isAvailable = false
    @Published var status = "Checking availability..."
    
    private let model = SystemLanguageModel.default
    private var session: LanguageModelSession?
    
    init() {
        checkAvailability()
    }
    
    private func checkAvailability() {
        switch model.availability {
        case .available:
            isAvailable = true
            status = "Ready"
            createSession()
        case .unavailable(.deviceNotEligible):
            status = "Device not supported"
        case .unavailable(.appleIntelligenceNotEnabled):
            status = "Enable Apple Intelligence in Settings"
        case .unavailable(.modelNotReady):
            status = "Model downloading..."
        case .unavailable(let other):
            status = "Unavailable: \(other)"
        }
    }
    
    private func createSession() {
        session = LanguageModelSession(
            model: model,
            instructions: "You are a helpful assistant."
        )
    }
    
    func generateText(_ prompt: String) async throws -> String {
        guard let session = session else {
            throw FoundationModelsError.sessionNotAvailable
        }
        
        let response = try await session.respond(to: prompt)
        return response.content
    }
    
    func generateStructured<T: Generable>(
        _ prompt: String, 
        type: T.Type
    ) async throws -> T {
        guard let session = session else {
            throw FoundationModelsError.sessionNotAvailable
        }
        
        let response = try await session.respond(
            to: prompt,
            generating: type
        )
        return response.content
    }
}

enum FoundationModelsError: Error {
    case sessionNotAvailable
    case modelUnavailable
}
```

## Key Documentation Links

- **Main Framework:** https://developer.apple.com/documentation/foundationmodels
- **SystemLanguageModel:** https://developer.apple.com/documentation/foundationmodels/systemlanguagemodel
- **LanguageModelSession:** https://developer.apple.com/documentation/foundationmodels/languagemodelsession
- **Guided Generation:** https://developer.apple.com/documentation/foundationmodels/generating-swift-data-structures-with-guided-generation
- **Tool Calling:** https://developer.apple.com/documentation/foundationmodels/expanding-generation-with-tool-calling
- **Safety Guidelines:** https://developer.apple.com/documentation/foundationmodels/improving-safety-from-generative-model-output
- **Acceptable Use:** https://developer.apple.com/apple-intelligence/acceptable-use-requirements-for-the-foundation-models-framework

## Common Patterns

### Simple Text Generation
```swift
let response = try await session.respond(to: "Summarize this text: \(inputText)")
```

### Structured Extraction
```swift
@Generable
struct Entities {
    let people: [String]
    let places: [String]
    let organizations: [String]
}

let entities = try await session.respond(
    to: "Extract entities from: \(text)",
    generating: Entities.self
)
```

### Streaming for Real-time UI
```swift
let stream = session.streamResponse(to: prompt)
for try await chunk in stream {
    await MainActor.run {
        responseText += chunk.content
    }
}
```

This framework provides powerful on-device AI capabilities while maintaining user privacy and system integration.